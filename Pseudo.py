# Pseudo.py
# To rotate, take the x axis as the zigzag direction and rotate the hole under the graphene
# This ammounts to rotating the positions (so the triangle rotates) and rotating the strain tensor
from scipy import *
from scipy.interpolate import griddata
from Constants import *
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d


def ImportReduce(dfiles,lt,q):
	# Loads in dfiles: First and Second column x, y (nm) third column strain (absolute)
	# Reduces the x, y, strain data toward unity by dividing lengths by lt and strains by q
	# Outputs the isolated list of x y coordinates and a three column list of corresponding strains exx,exy,eyy
	for i in range(3):
		temp=genfromtxt(dfiles[i])
		if i==0:
			strains=empty((temp.shape[0],3))
		strains[:,i]=temp[:,2]/q**(2/3)
	
	xy=empty((temp.shape[0],2))
	xy[:,0]=temp[:,0]/lt
	xy[:,1]=temp[:,1]/lt

	return (xy,strains)

def Rotate(xy,strains,theta):
	# Rotates the coordinates and the element of the tensor theta degrees CCW
	xy=column_stack((\
		cos(theta)*xy[:,0]-sin(theta)*xy[:,1],\
		sin(theta)*xy[:,0]+cos(theta)*xy[:,1]\
		))
	strains=column_stack((\
		cos(theta)**2*strains[:,0]-sin(2*theta)*strains[:,1]+sin(theta)**2*strains[:,2],\
		1/2.*sin(2*theta)*(strains[:,0]-strains[:,2])+cos(2*theta)*strains[:,1],\
		sin(theta)**2*strains[:,0]+sin(2*theta)*strains[:,1]+cos(theta)**2*strains[:,2]\
		))
	return (xy,strains)

def PVP(strains):
	# Returns the PVP without the leading factor betag*fq/(2*ag)
	# As well as the factor of q**(2/3) from reducing the strain
	Ax=1/(2*pi)*(strains[:,0]-strains[:,2])
	Ay=-1/pi*strains[:,1]

	return (Ax,Ay)

def InterpField(xy,Ax,Ay,xgr,ygr):
	# Takes the derivatives from interpolating Ax and Ay (at coordinates in xy) onto xgr, ygr to get B
	# Missing factors of betag*fq/(2*ag)*q**(2/3) from VP and factor of 1/lt from reduced lengths
		
	# Using the scipy function grid data
	# goes from x-y-z data to arrayed data
	gAx=griddata(xy,Ax,(xgr,ygr), method='linear',fill_value=nan)
	gAy=griddata(xy,Ay,(xgr,ygr), method='linear',fill_value=nan)

	# Getting derivatives:
	dL=abs(xgr[0,0]-xgr[0,1])
	dAxdy,junk=gradient(gAx,dL,dL)
	junk,dAydx=gradient(gAy,dL,dL)

	Bs=dAydx-dAxdy
	return Bs

def PMF(dfiles,lt,q,theta,xgrid,ygrid):
	# Calculates the pseudo magnetic field from dfiles generated by comsol
	# dfiles is a list of 3 files [exx,exy,eyy]
	# First and Second column x, y (m) third column strain (absolute)
	# lt=Fundamental length of the problem
	# q=Fundamental strain scale in the problem
	# theta=angle of rotation of the microchamber under the zigzag graphene direction
	# xgrid, ygrid--an array of x and y position to interpolate the PMF onto
	# Bs--outputted grid of PMF
	# BS, xgrid, and ygrid formatted like an image
	# [row,column]=[x,y] increasing with increasing index--first element lower left corner of image
	# x increases throughout a row
	# y increases each column

	# Import and reduce strain field (lengths/lt, strain/q**(2/3))
	(xy,strains)=ImportReduce(dfiles,lt,q)

	# Rotate: rotating the graphene above the stationary shape
	(xy,strains)=Rotate(xy,strains,theta)

	# Convert to pseudo vector potential, still 3 columns x, y, A
	(Ax,Ay)=PVP(strains)

	# Interpolate onto grid to get the PMF
	Bs=InterpField(xy,Ax,Ay,xgrid,ygrid)

	# Corrects for avoided constants
	# Missing factors of betag*fq/(2*ag)*q**(2/3) from VP and factor of 1/lt from reduced lengths
	Bs=Bs*betag*fq/(2*ag)*q**(2/3)/lt

	return Bs

def plotPMF(xgrid,ygrid,Bs,show=True,save=False,limits=False,figure=1,red=1):
	# Plot the PMF from PMF function
	# xgrid, ygrid--an array of x and y position to interpolate the PMF onto
	# Bs grid of PMF
	# BS, xgrid, and ygrid formatted like an image
	# [row,column]=[x,y] increasing with increasing index--first element lower left corner of image
	# x increases throughout a row
	# y increases each column
	# Options:
	# show--true or false based on whether it should be printed to screen
	# save--give a string of the filename to save to if you want to save out
	# limits--give a two element list of the lower and upper limit
	# figure--if you prefer a different figure number
	# red--Option to reduce the x and y extent of the plotted image
	fig=plt.figure(figure)
	plt.clf()
	ax=fig.add_subplot(111,aspect=1)
	plt.imshow(Bs,extent=(xgrid.min(),xgrid.max(),ygrid.min(),ygrid.max()),cmap=plt.cm.rainbow,aspect='equal',origin='lower')
	if limits!=False:
		plt.clim(limits[0],limits[1])
	plt.xlabel('x/L')
	plt.xlim(xgrid.min()*red,xgrid.max()*red)
	plt.ylabel('y/L')
	plt.ylim(ygrid.min()*red,ygrid.max()*red)
	cbar=plt.colorbar()
	cbar.set_label('B(T)')
	if show==True:
		plt.show()
	if save!=False:
		plt.savefig(save)

def plotPMFsingle(xgrid,ygrid,Bs,show=True,save=False,figure=1,strideL=8,Nlevels=7,expand=2.5):
	# Plot the PMF from PMF function
	# Nice single plot of the optimal rotation
	# xgrid, ygrid--an array of x and y position to interpolate the PMF onto
	# Bs grid of PMF
	# BS, xgrid, and ygrid formatted like an image
	# [row,column]=[x,y] increasing with increasing index--first element lower left corner of image
	# x increases throughout a row
	# y increases each column
	# Options:
	# show--true or false based on whether it should be printed to screen
	# save--give a string of the filename to save to if you want to save out
	# limits--give a two element list of the lower and upper limit
	# figure--if you prefer a different figure number
	# strideL--How far to stride in the columns and the rows of the Bs array for points to plot
	# Nlevels--The number of levels in the contour plot
	# expand--How far below the smallest value to plot the contour plot
	fig=plt.figure(figure)
	plt.clf()
	ax=fig.gca(projection='3d')
	surf=ax.plot_surface(xgrid,ygrid,Bs,\
		rstride=strideL,cstride=strideL,\
		linewidth=.1,antialiased=True,alpha=1,\
		vmin=nanmin(Bs), vmax=nanmax(Bs),cmap=plt.cm.rainbow,shade=True)
	cset=\
	ax.contourf(xgrid,ygrid,Bs,Nlevels,vmin=nanmin(Bs),vmax=nanmax(Bs),zdir='z',offset=nanmin(Bs)*expand,cmap=plt.cm.rainbow,shade=True)
	ax.contour( xgrid,ygrid,Bs,Nlevels,vmin=nanmin(Bs),vmax=nanmax(Bs),zdir='z',offset=nanmin(Bs)*expand,colors='black')

	ax.set_xlabel('x/L')
	ax.set_xlim(xgrid.min(),xgrid.max())
	ax.set_ylabel('y/L')
	ax.set_ylim(ygrid.min(),ygrid.max())
	ax.set_zlim(nanmin(Bs)*expand,nanmax(Bs))
	cbar=fig.colorbar(surf, shrink=0.5, aspect=10)
	cbar.set_label('B(T)')
	
	if show==True:
		plt.show()
	if save!=False:
		plt.savefig(save)